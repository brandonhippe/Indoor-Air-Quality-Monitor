#!/usr/bin/python

#============================ logging start ===================================
import logging
from SmartMeshSDK.utils import AppUtils
log = AppUtils.setupModuleLogging()

#============================ logging stop ====================================

from SmartMeshSDK.utils import FormatUtils

class NetworkHealthAnalyzer(object):
    
    TEST_OUTCOME_PASS   = 'PASS'
    TEST_OUTCOME_FAIL   = 'FAIL'
    TEST_OUTCOME_NOTRUN = 'NOTRUN'
    TEST_OUTCOME_ALL    = [TEST_OUTCOME_PASS,
                           TEST_OUTCOME_FAIL,
                           TEST_OUTCOME_NOTRUN]
    
    def __init__(self):
        
        # log
        log.info("creating instance")
    
    #======================== public ==========================================
    
    def analyze(self,data):
        returnVal = []
        
        for f in dir(self):
            
            if f.startswith("_nettest_"):
                
                # execute the test
                (outcome,description) = getattr(self,f)(data)
                assert outcome in self.TEST_OUTCOME_ALL
                assert type(description)==str
                
                # store outcome
                returnVal += [
                    {
                        'testName':       f,
                        'testDesc':       getattr(self,f).__doc__,
                        'outcome':        outcome,
                        'description':    description,
                    },
                ]
        
        return returnVal
    
    #======================== network tests ===================================
    
    #===== network availability
    
    MIN_NETWORKAVAILABILITY = 0.99
    
    def _nettest_networkAvailability(self,data):
        '''
        <p>
            This test verifies that the overall network availability is above the MIN_NETWORKAVAILABILITY threshold.
        </p>
        <p>
            The network availability is the portion of the packets generated by the mote applications that were 
            actually sent into the network. If the protocol stack is busy, it will reject the application's 
            data, resulting in a lower availability.
        </p>
        <p>
            This test is run once for the whole network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        # counters for number of packets generated/failed network-wide
        numTxOk              = 0
        numTxFail            = 0
        networkAvailability  = 0

        if (not data['devicehr']):
            descNOTRUN += [
                'This test could not run because device health reports are not received from the motes yet. \n'
            ]
        else :                     
            for (mac,dev_hr) in list(data['devicehr'].items()): 
                    
                # count number of packets generated/failed network-wide
                numTxOk     += dev_hr['numTxOk'] 
                numTxFail   += dev_hr['numTxFail']
 
            # run the test        
            if (not numTxOk):
                descNOTRUN      += [
                    'This test could not run because motes did not send any packets into the network (yet?)(numTxOk={0}) \n'.format(
                        numTxOk
                    )
                ]
            else:
                networkAvailability  = (1-float(numTxFail)/float(numTxOk + numTxFail))
            
                if (networkAvailability>=self.MIN_NETWORKAVAILABILITY):
                    descPASS    += [
                        'Network availability = {0} is more than MIN_NETWORKAVAILABILITY {1}. \n'.format(
                            networkAvailability,
                            self.MIN_NETWORKAVAILABILITY
                        )
                    ]
                else:
                    descFAIL    += [
                       'network availability={0} is less than MIN_NETWORKAVAILABILITY {1}. \n'.format(
                        networkAvailability,
                        self.MIN_NETWORKAVAILABILITY
                        )
                    ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
    
    #===== network reliability
    
    MIN_NETWORKRELIABILITY = 0.999
    
    def _nettest_networkReliability(self,data):
        '''
        <p>
            This test verifies that the overall network reliability is above the MIN_NETWORKRELIABILITY threshold.
        </p>
        <p>
            The network reliability is the portion of the packets injected into the network that were received 
            by their final destination. If the network loses data, then the network reliability goes down.
        </p>
        <p>
            This test is run once for the whole network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        # counters for number of packets generated/lost network-wide        
        numPktsGenerated     = 0
        numPktsLost          = 0
        
        for (mac,moteinfo) in list(data['moteinfo'].items()):            
        
            # count number of packets received/lost network-wide
            numPktsGenerated += moteinfo['packetsReceived'] 
            numPktsGenerated += moteinfo['packetsLost']
            numPktsLost      += moteinfo['packetsLost']
        
        # run the test        
        if (not numPktsGenerated):       
            descNOTRUN      += [
                'This test could not run because numPktsGenerated = {0} and so it is impossible to calculate a ratio. \n'.format(
                    numPktsGenerated,
                )
            ]     
        else :
            networkReliability = (1-float(numPktsLost)/float(numPktsGenerated))
            
            if (networkReliability>=self.MIN_NETWORKRELIABILITY):
                descPASS    += [
                    'Network reliability = {0}, which is above than minimum network reliability threshold {1}. \n'.format(
                        networkReliability,
                        self.MIN_NETWORKRELIABILITY,
                    )
                ]
            else:
                descFAIL    += [
                    'Network reliability = {0}, which is below than minimum network reliability threshold {1}. \n'.format(
                        networkReliability,
                        self.MIN_NETWORKRELIABILITY,
                    )
                ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
		
	#===== average network latency
	
    MAX_NETWORKLATENCY = 2000
    
    def _nettest_networkLatency(self,data):
        '''
        <p>
            This test verifies that the average network latency is below the MAX_NETWORKLATENCY threshold.
        </p>
        <p>
           Network latency is the average time (in milliseconds) taken for packets generated at mote to reach the manager.
        </p>
        <p>
            This test is run once for the whole network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        # run the test  
        if (data['networkinfo']['netLatency']<self.MAX_NETWORKLATENCY):
            descPASS    += [
                'Network latency is {0} ms, which is below than the maximum network latency threshold {1} ms. \n'.format(
                    data['networkinfo']['netLatency'],
                    self.MAX_NETWORKLATENCY,
                )
            ]
        else:
            descFAIL    += [
                'Network latency is {0} ms, which is above than the maximum network latency threshold {1} ms. \n'.format(
                    data['networkinfo']['netLatency'],
                    self.MAX_NETWORKLATENCY,
                )
            ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
		
    
    #===== multiple joins
    
    def _nettest_multipleJoins(self,data):
        '''
        <p>
            This test verifies that each mote has joined the same number of times as the AP.
        </p>
        <p>
            In a normal deployment, all motes should join exactly once. Joining
            more than once may indicate a mote reset.
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
		
		# get the number of times AP joined
        for (mac,moteinfo) in list(data['moteinfo'].items()):   
            
            if ('isAP' in moteinfo and moteinfo['isAP']==True):
                APJoins = moteinfo['numJoins']
                APmac   = mac
                break
                
        for (mac,moteinfo) in list(data['moteinfo'].items()):
               
            # run the test
            if ('numJoins' in moteinfo and 'isAP' in moteinfo and moteinfo['isAP']==False):		
                if(moteinfo['numJoins']<=APJoins):    		
                    descPASS     += ['- Mote {0} has joined {1} times, which is less than or equal to the number of times AP {2} joined = {3}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            moteinfo['numJoins'],
                            FormatUtils.formatMacString(APmac),
					        APJoins
                        )
                    ]
                else:
                    descFAIL     += ['- Mote {0} has joined {1} times, which is more than the number of times AP {2} joined = {3}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            moteinfo['numJoins'],
                            FormatUtils.formatMacString(APmac),
					        APJoins
                        )
                    ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
    
    #===== number of links
    
    MAX_AP_RXLINKS = 140
    MAX_MOTE_LINKS = 180
    
    def _nettest_numLinks(self,data):
        '''
        <p>
            This test verifies that the number of links assigned to each mote does not exceed the maximum limit.
        </p>
        <p>
            The manager is never supposed to allocate more than MAX_AP_RXLINKS receive links to the AP, 
            nor more than MAX_MOTE_LINKS links (both transmit and receive) for a non-AP mote.
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        # get all the paths in the network
        
        for (mac,moteinfo) in list(data['moteinfo'].items()):
            
            (numTx,numRx)    = self._countTxRxLinks(data['networkpaths'],mac)
            
            if moteinfo['isAP']:
                if numRx<self.MAX_AP_RXLINKS:
                    descPASS  += [
                        'AP {0} has {1} RX links, which is less than maximum AP links {2}.\n'.format(
                            FormatUtils.formatMacString(mac),
                            numRx,
                            self.MAX_AP_RXLINKS
                        )
                    ]
                else:
                    descFAIL  += [
                        'AP {0} has {1} RX links, which is more than maximum AP links {2}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            numRx,
                            self.MAX_AP_RXLINKS
                        )
                    ]
            else:
                numLinks = numTx+numRx
                if numLinks<self.MAX_MOTE_LINKS:
                    descPASS  += [
                        'mote {0} has {1} links, which is less than maximum mote links {2}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            numLinks,
                            self.MAX_MOTE_LINKS
                        )
                    ]
                else:
                    descFAIL  += [
                        'mote {0} has {1} links, which is more than maximum mote links {2}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            numLinks,
                            self.MAX_MOTE_LINKS
                        )
                    ]
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)

        # return test result
        return (outcome,description)
    
    #===== number of good neighbors
    
    MIN_NUMGOODNEIGHBORS = 3
    
    def _nettest_numGoodNeighbors(self,data):
        '''
        <p>
            This test verifies that each mote has enough good neighbors.
        </p>
        <p>
            The manager can build a robust network if each mote in the network has at least MIN_NUMGOODNEIGHBORS neighbors.
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        for (mac,moteinfo) in list(data['moteinfo'].items()):
            
            # run the test            
            if moteinfo['numGoodNbrs']>self.MIN_NUMGOODNEIGHBORS:
                descPASS += [
                    'Mote {0} has {1} good neighbors, which is more than the minimum number of good neighbors {2}. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['numGoodNbrs'],
                        self.MIN_NUMGOODNEIGHBORS
                    )
                ]
            else:
                descFAIL += [
                    'Mote {0} has {1} good neighbors, which is less than the minimum number of good neighbors {2}. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['numGoodNbrs'],
                        self.MIN_NUMGOODNEIGHBORS
                    )
                ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)

        # return test result
        return (outcome,description)
    
    
    #===== mote latency
    
    MAX_MOTELATENCY = 2000
    
    def _nettest_perMoteLatency(self,data):
        '''
        <p>
            This test verifies that the average latency for each mote is less than MAX_MOTELATENCY.
        </p>
        <p>
            Mote latency is the average time (in milliseconds) taken for packets generated at mote to reach the manager.
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        for (mac,moteinfo) in list(data['moteinfo'].items()):
            
            # run the test           
            if (moteinfo['avgLatency']>self.MAX_MOTELATENCY):
                descFAIL += [
                    'Latency for mote {0} is {1} ms, which is more than maximum average mote latency of {2} ms. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['avgLatency'],
                        self.MAX_MOTELATENCY
                    )
                ]
            else:
                descPASS += [
                    'Latency for mote {0} is {1} ms, which is less than maximum average mote latency of {2} ms. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['avgLatency'],
                        self.MAX_MOTELATENCY
                    )
                ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        
        return (outcome,description)
    
    
    #===== single parent
    
    def _nettest_oneSingleParentMote(self,data):
        '''
        <p>
            This test verifies that there is exactly one mote with only one parent.
        </p>
        <p>
            Graph theory indicates that, when building a bi-DAG, exactly one node ends up with one parent 
            (it will be a one-hop neighbor of the root). This test verifies that this is the case in this network.
        </p>
        <p>
            This test is run once for the whole network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        numParents           = {}
        singleParentMotes    = []
        
        # count number of parents for each mote
        for mac in list(data['moteinfo'].keys()):
            numParents[mac] = 0
            for ((fromMote,toMote),pathInfo) in list(data['networkpaths'].items()):
                if fromMote==mac and pathInfo['direction']==2 and pathInfo['numLinks']>0:
                    numParents[mac] += 1
        
        # count number of single-parents motes
        for (mac,n) in list(numParents.items()):
            if n==1:
                singleParentMotes      = [mac]
        
        # run the test
        if len(singleParentMotes)==1:
            descPASS    += [
                'Only mote {0} has a single parent. \n'.format(
                    FormatUtils.formatMacString(singleParentMotes[0]),
                )
            ]
        else:
            description  = []
            description += ['The following {0} motes have one parent only: '.format(len(singleParentMotes))]
            description += [' '.join(FormatUtils.formatMacString(m) for m in singleParentMotes)]
            description  = ''.join(description)
            descFAIL    += [description]
            
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
    		
    #===== Insufficient Bandwidth
    
    def _nettest_insufficientBandwidth(self,data):
        '''
        <p>
            This test verifies that the mote has enough bandwidth assigned to it. 
        </p>
        <p>
            The manager keeps track of the requested and assigned bandwidth for each mote. 
            The assigned bandwidth for each mote should be at least the bandwidth requested 
            by the mote plus the bandwidth required by the mote children. 

            The bandwidth numbers in this test indicate the interval between packets, so 
            lower values represent more frequent transmissions, which is typically considered 
            higher bandwidth. 
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        for (mac,moteinfo) in list(data['moteinfo'].items()):        
            
            #run the test    
            if moteinfo['totalNeededBw']>=moteinfo['assignedBw']:
                descPASS += [
                    'Total needed bandwidth for mote {0} is {1} ms, which is greater than or equal to assigned bandwidth {2} ms. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['totalNeededBw'],
                        moteinfo['assignedBw']
                    )
                ]
            else:
                descFAIL += [
                    'Total needed bandwidth for mote {0} is {1} ms, which is less than assigned bandwidth {2} ms. \n'.format(
                        FormatUtils.formatMacString(mac),
                        moteinfo['totalNeededBw'],
                        moteinfo['assignedBw']
                    )
                ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
	
	
    #===== mote availability
    
    MIN_MOTEAVAILABILITY = 0.99
    
    def _nettest_perMoteAvailability(self,data):

        '''   
        <p>
            This test verifies that the availability for each mote is more than MIN_MOTEAVAILABILITY.
        </p>
        <p>
            The mote availability is the portion of the packets generated by the mote's application that were 
            actually sent into the network. If the mote's protocol stack is busy, it will reject the
            application's data, resulting in a lower availability.
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''   
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
       
        if (not data['devicehr']):
            descNOTRUN += [
                'This test could not run because device health reports are not received from the motes yet. \n'
            ]
        else :                     
            for (mac,dev_hr) in list(data['devicehr'].items()):
            
                if not dev_hr['numTxOk']:
                    descNOTRUN += [
                        'This test could not run because mote {0} did not send any packets succesfully (yet?) (numTxOk=={1}) and so its\'s impossible to calculate a ratio. \n'.format(
                            FormatUtils.formatMacString(mac),
                            dev_hr['numTxOk']
                        )
                    ]
                    continue
            
                # run the test
                availability = (1-float(dev_hr['numTxFail'])/float(dev_hr['numTxOk'] + dev_hr['numTxFail']))
                if availability<self.MIN_MOTEAVAILABILITY:
                    descFAIL += [
                        'Availability for mote {0} is {1}, expected at least minimum mote availability of {2}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            availability,
                            self.MIN_MOTEAVAILABILITY
                        )
                    ]
                else:
                    descPASS += [
                        'Availability for mote {0} is {1}, which is better than minimum mote availability of {2}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            availability,
                            self.MIN_MOTEAVAILABILITY
                        )
                    ]
          
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)  
  
  
    #===== mote congestion
    
    AVG_QUEUE_LEN  = 1
    MAX_QUEUE_LEN  = 3
    
    def _nettest_moteCongestion(self,data):

        '''   
        <p>
            This test checks whether there is congestion at a mote.
        </p>
        <p>
            Mote queue occupancy information, obtained from the device health report, can help identify 
            congestion at a mote.  As a rule of thumb, motes that have an average queue length greater than 0 
            are in danger of seeing congestion. Motes that have a maximum queue length of 4 or more 
            may have experienced acute congestion during the interval. 
            Finally, congested motes typically have higher latency than their peers. 
        </p>
        <p>
            This test is run once for each mote in the network.
        </p>
        '''   
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
       
        if (not data['devicehr']):
            descNOTRUN += [
                'This test could not run because device health reports are not received from the motes yet. \n'
            ]
        else :                     
            for (mac,dev_hr) in list(data['devicehr'].items()):          
            
                # run the test
                avgQueueLen  = (dev_hr['queueOcc'] & 0x0F)
                maxQueueLen  = ((dev_hr['queueOcc'] & 0xF0) >> 4)
                
                if (avgQueueLen>self.AVG_QUEUE_LEN or maxQueueLen>self.MAX_QUEUE_LEN or dev_hr['numTxFail']>0) : 
                    descFAIL += [
                        'Mote {0} is congested, average queue occupancy is {1}, max queue occupancy is {2}, numTxFail is {3}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            avgQueueLen,
                            maxQueueLen,
                            dev_hr['numTxFail']
                        )
                    ]
                else:
                    descPASS += [
                        'Mote {0} is not congested, average queue occupancy is {1}, max queue occupancy is {2}, numTxFail is {3}. \n'.format(
                            FormatUtils.formatMacString(mac),
                            avgQueueLen,
                            maxQueueLen,
                            dev_hr['numTxFail']
                        )
                    ]
          
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
        
    #===== stability vs. RSSI
    
    THRES_NUM_PACKETS   = 30
    THRES_HIGH_RSSI     = -70
    THRES_HIGH_STAB     = 70
    THRES_LOW_RSSI      = -80
    THRES_LOW_STAB      = 50
    
    def _nettest_stabilityVsRssi(self,data):
        '''
        <p>
            This test verifies that the stability of a path is plausible given its RSSI.
        </p>
        <p>
            In the absence of heavy interference, there is a straightforward relationship between the RSSI and stability of a path:
            <ul>
                <li>If the RSSI is above THRES_HIGH_RSSI, the stability is
                expected to be above THRES_HIGH_STAB.</li>
                <li>If the RSSI is below THRES_LOW_RSSI, the stability is expected to
                be below THRES_LOW_STAB.</li>
            </ul>
        </p>
        <p>
            The stability is calculated as the ratio between the number of packets transmitted successfully and transmission attempts;
            it is also known as Packet Delivery Ratio (PDR).
        </p>
        <p>
            This test is run once for each path in the network over which at least THRES_NUM_PACKETS packets have been transmitted.
        </p>
        '''
        
        descPASS             = []
        descFAIL             = []
        descNOTRUN           = []
        
        for ((fromMote,toMote),pathInfo) in list(data['networkpaths'].items()):
                     
            # run the test
            linkStability = pathInfo['quality']
            linkRssi      = pathInfo['rssiSrcDest']
            
            # test for high RSSI
            if linkRssi>self.THRES_HIGH_RSSI:
                if linkStability>self.THRES_HIGH_STAB:
                    descPASS += [
                        'link {0}->{1} has RSSI {2} > {3} and stability {4} > {5}. \n'.format(
                            FormatUtils.formatMacString(fromMote),
                            FormatUtils.formatMacString(toMote),
                            linkRssi,
                            self.THRES_HIGH_RSSI,
                            linkStability,
                            self.THRES_HIGH_STAB,
                        )
                    ]
                else:
                    descFAIL += [
                        'link {0}->{1} has RSSI {2} > {3} and stability {4} < {5}. \n'.format(
                            FormatUtils.formatMacString(fromMote),
                            FormatUtils.formatMacString(toMote),
                            linkRssi,
                            self.THRES_HIGH_RSSI,
                            linkStability,
                            self.THRES_HIGH_STAB,
                        )
                    ]
            
            # test for low RSSI
            if linkRssi<self.THRES_LOW_RSSI:
                if linkStability<self.THRES_LOW_STAB:
                    descPASS += [
                        'link {0}->{1} has RSSI {2} < {3} and stability {4} < {5}. \n'.format(
                            FormatUtils.formatMacString(fromMote),
                            FormatUtils.formatMacString(toMote),
                            linkRssi,
                            self.THRES_LOW_RSSI,
                            linkStability,
                            self.THRES_LOW_STAB,
                        )
                    ]
                else:
                    descFAIL += [
                        'link {0}->{1} has RSSI {2} < {3} and stability {4} > {5}. \n'.format(
                            FormatUtils.formatMacString(fromMote),
                            FormatUtils.formatMacString(toMote),
                            linkRssi,
                            self.THRES_LOW_RSSI,
                            linkStability,
                            self.THRES_LOW_STAB,
                        )
                    ]
        
        # decide outcome
        if   descFAIL:
            outcome     = self.TEST_OUTCOME_FAIL
        elif descPASS:
            outcome     = self.TEST_OUTCOME_PASS
        else:
            outcome     = self.TEST_OUTCOME_NOTRUN
        
        # write report
        description  = []
        if descPASS:
            description  += ["PASS:"]
            description  += descPASS
        if descFAIL:
            description  += ["FAIL:"]
            description  += descFAIL
        if descNOTRUN:
            description  += ["NOTRUN:"]
            description  += descNOTRUN
        description = '<br/>'.join(description)
        
        # return test result
        return (outcome,description)
        	
    #======================== helpers =========================================
    
    def _countTxRxLinks(self,paths,mac):
        
        numTx           = 0
        numRx           = 0
        
        for ((fromMote,toMote),pathInfo) in list(paths.items()):
            
            if mac!=fromMote and mac!=toMote:
                continue
            
            if mac==fromMote:
                numTx  += pathInfo['numLinks']
            if mac==toMote:
                numRx  += pathInfo['numLinks']
        
        return (numTx,numRx)
